// Leaflet map object
var map = L.map('map', {
    zoomControl: false,
    fullscreenControl: true
});

// Bounding box
var corner1 = L.latLng(55.253461463214126, -139.0196808469),
    corner2 = L.latLng(35.329795743702064, -111.463262),
    bounds = L.latLngBounds(corner1, corner2);
map.fitBounds([
    [49.3632412491, -126.0326203],
    [40.0219407235, -118.7486847531]
]);
map.options.minZoom = 6;
map.options.maxZoom = 15;
map.options.maxBounds = bounds;

// Leaflet zoom control
L.control.zoom({position: "bottomright"}).addTo(map);

$(document).ready(function() {
    $(".info").hide();
});

// Mapbox shellfish base map
var mapbox_shellfish = L.tileLayer('https://api.mapbox.com/styles/v1/katzbr/cjshza9xf1db51fqgpriounjs/tiles/256/{z}/{x}/{y}?access_token=pk.eyJ1Ijoia2F0emJyIiwiYSI6ImNqOHhmMnBucDIwZm4ycW8ya2d5cHF0cmsifQ.8rcjz0DyWs_ncWfOZ0VwKA', {
    attribution: 'Created by <a href="https://github.com/briangkatz/">Brian G. Katz</a> | <a href="assets/license.txt">Mapbox</a> | Grower data &copy; <a href="https://pcsga.org/search-our-growers/">PCSGA</a>',
    detectRetina: true,
    style: 'assets/style.json'
}).addTo(map);

// Mapbox satellite base map
var mapbox_satellite = L.tileLayer('https://api.mapbox.com/styles/v1/katzbr/cjhxps6ae204n2rpneg2yutrn/tiles/256/{z}/{x}/{y}?access_token=pk.eyJ1Ijoia2F0emJyIiwiYSI6ImNqOHhmMnBucDIwZm4ycW8ya2d5cHF0cmsifQ.8rcjz0DyWs_ncWfOZ0VwKA', {
    attribution: 'Created by <a href="https://github.com/briangkatz/">Brian G. Katz</a> | <a href="assets/license2.txt">Mapbox</a> | Grower data &copy; <a href="https://pcsga.org/search-our-growers/">PCSGA</a>',
    detectRetina: true,
    style: 'assets/style2.json'
});

var grades = [0, 1, 2, 3, 4, 5];

var colors = chroma.scale(['#415F5D', '#A5BF15']).mode('hsl').colors(grades.length);

function getColor(d) {
    for (var i = 0; i < grades.length - 1; i++) {
        if ( d > grades[i] && d < grades[i+1] ) return colors[i];
    }
    if (d > grades[grades.length - 1]) return colors[grades.length];
}

// Set function for color ramp
var vulnColors = chroma.scale('OrRd').mode('lab').colors(4);

function setColor(vuln) {
    var id = 0;
    if (vuln === 4) { id = 3; }  // High (H/L)
    else if (vuln === 3) { id = 2; }  // Medium (H/H)
    else if (vuln === 2) { id = 1; }  // Medium (L/L)
    else  { id = 0; }  // Low (L/H)
    return vulnColors[id];
}

// Set style function that sets fill color property based on vulnerability group
function vulnStyle(feature) {
    return {
        fillColor: setColor(feature.properties.cluster),
        fillOpacity: 0.6,
        weight: 1,
        opacity: 1,
        color: '#000000',
        dashArray: '1'
    };
}

function style(feature) {
    return {
        weight: 2,
        opacity: 0,
        color: '#ffffff',
        dashArray: '10',
        fillOpacity: 0.25,
        fillColor: getColor(feature.properties.numstake)
    };
}

var estuaryColors = chroma.scale('Reds').mode('lab').colors(6);

function getColorEstuaries(troph) {
    var id = 0;
    if (troph === 5) { id = 5; }  // High
    else if (troph === 4) { id = 4; }  // Medium-High
    else if (troph === 3) { id = 3; }  // Medium
    else if (troph === 2) { id = 2; }  // Medium-Low
    else if (troph === 1) { id = 1; }  // Low
    else  { id = 0; }  // Undefined
    return estuaryColors[id];
}

function eutrophStyle(feature) {
    return {
        fillColor: getColorEstuaries(feature.properties.trophlevel),
        fillOpacity: 0.6,
        weight: 1,
        opacity: 1,
        color: '#000000',
        dashArray: '1'
    }
}

function highlightFeatureEstuaries(e) {
    var layer = e.target;
    layer.setStyle({
        weight: 2,
        opacity: 0.8,
        color: '#E0631D',
        fillColor: '#ffffff',
        fillOpacity: 0.8
    });
    layer.bringToFront();
}

function zoomToFeatureEstuaries(e) {
    map.fitBounds(e.target.getBounds());
}

function resetHighlightEstuaries(e) {
    estuaries.resetStyle(e.target);
    $(".info").hide();
}

function onEachFeatureEstuaries(feature, layer) {
    layer.on({
        mouseover: highlightFeatureEstuaries,
        click: zoomToFeatureEstuaries,
        mouseout: resetHighlightEstuaries
    });
    layer.bindTooltip('<h4>' + feature.properties.Name + '</h4><h6>Eutrophication Risk: ' + feature.properties.oec + '</h6>', {sticky: true, className: "feature-tooltip"});
}

function highlightFeature(e) {
    var layer = e.target;
    layer.setStyle({
        weight: 2,
        opacity: 0.8,
        color: '#E0631D',
        fillColor: '#ffffff',
        fillOpacity: 0.8
    });
    layer.bringToFront();
    // Select the update class, and update the content with the input value.
    $(".update").html('<b><h2>' + layer.feature.properties.name + '</b></h2>' + '<h1>Vulnerability to OA:</h1><b>Exposure: ' + layer.feature.properties.exposure + ' </b><br>' + '<b>Sensitivity: ' + layer.feature.properties.sensitivty + ' </b><br>' + '<b>Adaptive Capacity: ' + layer.feature.properties.adptvcapac + '</b>');
    $(".info").show();
}

function zoomToFeature(e) {
    map.fitBounds(e.target.getBounds());
}

function resetHighlight(e) {
    vulnerability.resetStyle(e.target);
    $(".info").hide();
}

function onEachFeature(feature, layer) {
    layer.on({
        mouseover: highlightFeature,
        click: zoomToFeature,
        mouseout: resetHighlight
    });
}

function hexStyle(feature) {
    return {
        fillColor: '#ffffff',
        fillOpacity: 0.1,
        weight: 1,
        opacity: 1,
        color: '#000000',
        dashArray: '1'
    }
}

function highlightFeatureHexagon(e) {
    var layer = e.target;
    layer.setStyle({
        weight: 2,
        opacity: 0.8,
        color: '#E0631D',
        fillColor: '#ffffff',
        fillOpacity: 0.8
    });
    layer.bringToFront();
    // Select the update class, and update the content with the input value.
    $(".update").html('<b># Harvest Sites: ' + layer.feature.properties.hrvstSites + '</b><br><b># Monitoring: ' + layer.feature.properties.monitoring + '</b><br><b># Research Projects: ' + layer.feature.properties.oahProjs + '</b><br><b>Yield probability: TBD</b>');
    $(".info").show();
}

function zoomToFeatureHexagon(e) {
    map.fitBounds(e.target.getBounds());
}

function resetHighlightHexagon(e) {
    hexagons.resetStyle(e.target);
    $(".info").hide();
}

function onEachFeatureHexagon(feature, layer) {
    layer.on({
        mouseover: highlightFeatureHexagon,
        click: zoomToFeatureHexagon,
        mouseout: resetHighlightHexagon
    });
}

// Estuaries/Eutrophication
var estuaries = null;
estuaries = L.geoJson.ajax("assets/data/estuaries.geojson", {
    style: eutrophStyle,
    onEachFeature: onEachFeatureEstuaries
});

// Vulnerability Watersheds
var vulnerability = null;
vulnerability = L.geoJson.ajax("assets/data/vulnerability_watersheds.geojson", {
    style: vulnStyle,
    onEachFeature: onEachFeature
});

// Hexagonal Grid
var hexagons = null;
hexagons = L.geoJson.ajax("assets/data/hexagons.geojson", {
    style: hexStyle,
    onEachFeature: onEachFeatureHexagon
});

// Define legend
var legend = L.control({position: 'bottomright'});
// Set legend color scale and breaks
legend.onAdd = function () {
    var div = L.DomUtil.create('div', 'legend legend-colors');
    div.innerHTML += '<b># Months Below &Omega;<sub>ar</sub> 1.5 (2050)</b><br /><br>';
    div.innerHTML += '<i style="background: ' + '#E0631D' + '; opacity: 1"></i><p>7-8</p>';
    div.innerHTML += '<i style="background: ' + '#A5BF15' + '; opacity: 1"></i><p>5-6</p>';
    div.innerHTML += '<i style="background: ' + '#E3ED00' + '; opacity: 1"></i><p>3-4</p>';
    div.innerHTML += '<i style="background: ' + '#ffffff' + '; opacity: 1"></i><p> 1-2</p>';
    return div;
};

// Scale bar
L.control.scale({position: 'bottomright'}).addTo(map);

// Set SVG width, height based on viewing window size
function setWidth(window) {
    var width = $(window).width() * 0.325;  // large
    if ($(window).width() < 1920 && $(window).width() > 1024) { width = $(window).width() * 0.3; }  // medium
    else if ($(window).width() <= 1024) { width = $(window).width() * 0.9; }  // small
    return width;
}
function setHeight(window) {
    var height = $(window).height() * 0.195;  // large
    if ($(window).height() < 1280 && $(window).height() > 857) { height = $(window).height() * 0.225; }  // medium
    else if ($(window).height() <= 857) { height = $(window).height() * 0.33; }  // small
    else if ($(window).height() >= 2000) { height = $(window).height() * 0.225; }  // x-large
    return height;
}
function setBarHeight(window) {
    var height = $(window).height() * 0.195;  // large
    var intFreqHeight = height;  // height of intensity & frequency bar charts
    if ($(window).height() < 1280 && $(window).height() > 857) { height = $(window).height() * 0.225; intFreqHeight = height * 0.5; }  // medium
    else if ($(window).height() <= 857) { height = $(window).height() * 0.33; intFreqHeight = height * 0.4; }  // small
    else if ($(window).height() >= 2000) { height = $(window).height() * 0.5; intFreqHeight = height * 0.45; }  // x-large
    return intFreqHeight;
}

// Species Responses
d3.csv("assets/data/species.csv").then(d => chart(d))

function chart(data) {

	var keys = data.columns.slice(1);

	var parseTime = d3.timeParse("%Y%m%d"),
		formatDate = d3.timeFormat("%Y-%m-%d"),
		bisectDate = d3.bisector(d => d.omega_arag).left,
		formatValue = d3.format(",.0f"),
		formatFloat = d3.format(".1f");

	data.forEach(function(d) {
		d.date = parseTime(d.date);
		d.omega_arag = formatFloat(d.omega_arag);
		return d;
	})

	var width = setWidth(window);
	var height = setHeight(window);

	var svg = d3.select("#species-response-chart")
	    .attr("width", width)
	    .attr("height", height),
		margin = {
		    top: 15,
		    right: 10,
		    bottom: 15,
		    left: 40
		},
		width = +svg.attr("width"),
		height = +svg.attr("height") - margin.top - margin.bottom;

	var x = d3.scaleLinear()
		.rangeRound([margin.left, width - margin.right])
		.domain(d3.extent(data, d => d.omega_arag))
		.range([width - margin.right, margin.left])

	var y = d3.scaleLinear()
		.rangeRound([height - margin.bottom, margin.top]);

	var z = d3.scaleOrdinal(d3.schemePaired);

	var line = d3.line()
		.curve(d3.curveCardinal)
		.x(d => x(d.omega_arag))
		.y(d => y(d.response));

	svg.append("g")
		.attr("class","x-axis")
		.attr("transform", "translate(0," + (height - margin.bottom) + ")")
		.call(d3.axisBottom(x).tickFormat(d3.format(".1f")));

	svg.append("text")
      .attr("transform",
            "translate(" + (width/2) + " ," +
                           (height + margin.top + 10) + ")")
      .style("text-anchor", "middle")
      .text("Aragonite saturation state");

	svg.append("g")
		.attr("class", "y-axis")
		.attr("transform", "translate(" + margin.left + ",0)");

	svg.append("text")
		  .attr("transform", "rotate(-90)")
		  .attr("y", -2)
		  .attr("x", 0 - (height / 2))
		  .attr("dy", "1em")
		  .style("text-anchor", "middle")
		  .text("Growth (% change from pre-industrial)");

	var mean_arag = svg.append("g")
		.attr("class", "focus")
		.style("display", "block");

	mean_arag.append("line").attr("class", "lineHover")
		.style("stroke", "#999")
		.attr("stroke-width", 1)
		.style("shape-rendering", "crispEdges")
		.style("opacity", 0.5)
		.attr("y1", -height)
		.attr("y2",0);

	var focus = svg.append("g")
		.attr("class", "focus")
		.style("display", "none");

	focus.append("line").attr("class", "lineHover")
		.style("stroke", "#999")
		.attr("stroke-width", 1)
		.style("shape-rendering", "crispEdges")
		.style("opacity", 0.5)
		.attr("y1", -height)
		.attr("y2",0);

	focus.append("text").attr("class", "lineHoverArag")
		.attr("text-anchor", "middle")
		.attr("font-size", 14);

	var overlay = svg.append("rect")
		.attr("class", "overlay")
		.attr("x", margin.left)
		.attr("width", width - margin.right - margin.left)
		.attr("height", height)

	update(d3.select('#selectbox').property('value'), 0);

	function update(input, speed) {

		var copy = keys.filter(f => f.includes(input))

		var species_all = copy.map(function(id) {
			return {
				id: id,
				values: data.map(d => {return {omega_arag: d.omega_arag, response: +d[id]}})
			};
		});

		y.domain([
			d3.min(species_all, d => d3.min(d.values, c => c.response)),
			d3.max(species_all, d => d3.max(d.values, c => c.response))
		]).nice();

		svg.selectAll(".y-axis").transition()
			.duration(speed)
			.call(d3.axisLeft(y).tickSize(-width + margin.right + margin.left))

		var species = svg.selectAll(".species_all")
			.data(species_all);

		species.exit().remove();

		species.enter().insert("g", ".focus").append("path")
			.attr("class", "line species_all")
			.style("stroke", d => z(d.id))
			.merge(species)
		.transition().duration(speed)
			.attr("d", d => line(d.values))

		tooltip(copy);
	}

	function tooltip(copy) {

		var labels = focus.selectAll(".lineHoverText")
			.data(copy)

		labels.enter().append("text")
			.attr("class", "lineHoverText")
			.style("fill", d => z(d))
			.attr("text-anchor", "start")
			.attr("font-size",12)
			.attr("dy", (_, i) => 1 + i * 2 + "em")
			.merge(labels);

		var circles = focus.selectAll(".hoverCircle")
			.data(copy)

		circles.enter().append("circle")
			.attr("class", "hoverCircle")
			.style("fill", d => z(d))
			.attr("r", 2.5)
			.merge(circles);

        // Have an overlay line appear and disappear over the species response curves on mouseover/mouseout
		svg.selectAll(".overlay")
			.on("mouseover", function() { focus.style("display", null); })
			.on("mouseout", function() { focus.style("display", "none"); })
			.on("mousemove", mousemove);

        // Function to display data values (y) respective to mouse hover location (x)
		function mousemove() {

			var x0 = x.invert(d3.mouse(this)[0]),
				i = bisectDate(data, x0, 1),
				d0 = data[i - 1],
				d1 = data[i],
				d = x0 - d0.omega_arag > d1.omega_arag - x0 ? d1 : d0;

			focus.select(".lineHover")
				.attr("transform", "translate(" + x(d.omega_arag) + "," + height + ")");

			focus.select(".lineHoverArag")
				.attr("transform",
					"translate(" + x(d.omega_arag) + "," + (height + margin.bottom) + ")")
				.text(d.omega_arag);

            // Circles move along data values at the mouse hover event location, i.e. y(d[e])
			focus.selectAll(".hoverCircle")
				.attr("cy", e => y(d[e]))
				.attr("cx", x(d.omega_arag));

			focus.selectAll(".lineHoverText")
				.attr("transform",
					"translate(" + (x(d.omega_arag)) + "," + height / 2.5 + ")")
				// Display data headings and values on overlay line
				.text(e => e.split("_")[1].split('-').join(' ') + ": " + formatValue(d[e]) + "%");

			x(d.omega_arag) > (width - width / 4)
				? focus.selectAll("text.lineHoverText")
					.attr("text-anchor", "end")
					.attr("dx", -10)
				: focus.selectAll("text.lineHoverText")
					.attr("text-anchor", "start")
					.attr("dx", 10)
		}
	}

	var selectbox = d3.select("#selectbox")
		.on("change", function() {
			update(this.value, 750);
		})


    // Multi-coordinated view geovisualization
    var arag_events = d3.json('assets/data/corrosive_arag_nearshore.geojson').then(function(data) {

        var filter = crossfilter(data.features);

        var all = filter.groupAll();



        var everything = filter.dimension(function(d) {
            return d
        });

        var geomDimension = filter.dimension(function(d) {
            return d.geometry
        });

        var intDimension = filter.dimension(function(d) {
            var min_arag = d.properties.min_arag;
            return min_arag < 0.9 ? '0.90-0.75' :
                min_arag < 1.05 ? '1.05-0.90' :
                    min_arag < 1.2 ? '1.20-1.05' :
                        min_arag < 1.35 ? '1.35-1.20' :
                            '1.40-1.35'
        });

        var freqDimension = filter.dimension(function(d) {
            var freq = d.properties.freq;
            return freq < 5 ? '0.00-0.05' :
                freq < 10 ? '0.05-0.10' :
                    freq < 15 ? '0.10-0.15' :
                        freq < 20 ? '0.15-0.20' :
                            '0.20+'
        });

        var dateDimension = filter.dimension(function(d) {
            return d3.timeDay(new Date(d.properties.time_max));
        });

        var intDimensionGroup = intDimension.group();

        var freqDimensionGroup = freqDimension.group();

        var dateDimensionGroup = dateDimension.group(); //

        var geoJsonLayer = L.geoJson({
            type: 'FeatureCollection',
            features: geomDimension.top(Infinity)
        }, {
            pointToLayer: function(feature, latlng) {
                return L.circleMarker(latlng, {
                    radius: Math.pow(feature.properties.min_arag, -5) * 5,
                    fillColor: "#ff8000",
                    color: "#ff8000",
                    weight: 5,
                    stroke: false,
                    opacity: 0.5,
                    fillOpacity: 0.5
                })
            },
            onEachFeature: function(feature, layer) {
                layer.bindTooltip("&Omega; Aragonite: " + feature.properties.min_arag.toFixed(2).toString(), {className: 'aragTooltip'});
            }
            }).addTo(map);

        var intChart = dc.barChart('#int-chart');

        var intOrder = [
          {range: "1.40-1.35", order: 4},
          {range: "1.35-1.20", order: 3},
          {range: "1.20-1.05", order: 2},
          {range: "1.05-0.90", order: 1},
          {range: "0.90-0.75", order: 0}
        ];

        var sortByOrder = intOrder.sort(function (a, b) { return a.order > b.order; });
        var arag_ranges = sortByOrder.map(function (d) { return d.range; });

        intChart
            .width(setWidth(window))
            .height(setBarHeight(window))
            .margins({
                top: 10,
                right: 10,
                bottom: 40,
                left: 40
            })
            .dimension(intDimension)
            .group(intDimensionGroup)
            .elasticY(true)
            .x(d3.scaleBand().domain(arag_ranges))
            .xUnits(dc.units.ordinal)
            .yAxis()
            .ticks(3);

        var freqChart = dc.barChart('#freq-chart');

        freqChart
            .width(setWidth(window))
            .height(setBarHeight(window))
            .margins({
                top: 10,
                right: 10,
                bottom: 40,
                left: 40
            })
            .dimension(freqDimension)
            .group(freqDimensionGroup)
            .elasticY(true)
            .x(d3.scaleBand())
            .xUnits(dc.units.ordinal)
            .yAxis()
            .ticks(3);

        var dateChart = dc.lineChart('#date-chart');

            dateChart
            .renderArea(true)
            .height(setHeight(window))
            .width(setWidth(window))
            .transitionDuration(1000)
            .margins({
                top: 10,
                right: 10,
                bottom: 40,
                left: 20
            })
            .dimension(dateDimension)
            .group(dateDimensionGroup)
            .elasticY(true)
            .x(d3.scaleTime().domain([new Date(1994, 12), new Date(2051, 1)]))
            .xUnits(d3.timeYears)
            .yAxisMax = function() { return 12; };;

        dc.renderAll();

        function updateMapFilter() {
            geomDimension.filter(function(d) {
                return map.getBounds().contains(L.geoJSON(d).getBounds());
            });
            dc.redrawAll();
        }

        function updateMap() {
            geoJsonLayer.clearLayers();
            geoJsonLayer.addData({
                type: 'FeatureCollection',
                features: everything.top(Infinity)
            });
        }

        function calcMeanArag() {
            var total_hotspots = all.value();
            var arag_values = [];
            for (var i in geoJsonLayer._layers) {
                arag_values.push(geoJsonLayer._layers[i].feature.properties.min);
            }
            var arrAvg = arag_values.reduce((a,b) => a + b, 0) / arag_values.length;

            mean_arag.select(".lineHover")
                .attr("transform", "translate(" + x(arrAvg) + "," + height + ")");

            mean_arag.select(".lineHoverArag")
                .attr("transform",
                    "translate(" + x(arrAvg) + "," + (height + margin.bottom) + ")");
            console.log("Aragonite saturation state (mean): " + arrAvg);
            return arrAvg;
        }

        map.on('zoomend moveend', function() {
            updateMapFilter();
            updateMap();
            calcMeanArag();
        });

        intChart.on('filtered', function(chart, filter) {
            updateMap();
            calcMeanArag();
        });

        freqChart.on('filtered', function(chart, filter) {
            updateMap();
            calcMeanArag();
        });

        dateChart.on('filtered', function(chart, filter) {
            updateMap();
            calcMeanArag();
        });

    });

    var stakeholders = L.geoJson.ajax('assets/data/stakeholders.geojson', {
        pointToLayer: function(feature, latlng) {
            return L.circleMarker(latlng, {
                radius: 40,
                fillColor: "#738D2B",
                color: "#000",
                weight: 1,
                stroke: false,
                opacity: 0.01,
                fillOpacity: 0.1
            })
        }
    });

    var projects = L.geoJson.ajax('assets/data/oah_projects.geojson', {
        pointToLayer: function (feature, latlng) {
            return L.circleMarker(latlng, {
                radius: 40,
                fillColor: "#08048d",
                color: "#000",
                weight: 1,
                stroke: false,
                opacity: 0.01,
                fillOpacity: 0.04
            })
        },
        onEachFeature: function (feature, layer) {
            layer.bindTooltip(feature.properties.project, {sticky: true, className: "feature-tooltip"});
        }
    });

    // Layer control
    var estuary_layer = L.layerGroup([estuaries]);
    var hexGrid = L.layerGroup([hexagons]);
    var vulnWatersheds = L.layerGroup([vulnerability]);
    var stakeholder_groups = L.layerGroup([stakeholders]);
    var ac_projects = L.layerGroup([projects]);

    var base_maps = {
        "Shellfish": mapbox_shellfish,
        "Satellite": mapbox_satellite
    };

    var vulnerability_layers = {
        "Exposure": estuary_layer,
        "Sensitivity": stakeholder_groups,
        "Adaptive Capacity": ac_projects,
        "Combined Vulnerability": vulnWatersheds,
        "Yield Probability": hexGrid
    };

    L.control.layers(base_maps, vulnerability_layers, {
            position: 'topright',
            collapsed: true
    }).addTo(map);

    $("#sidenavToggler").click(function() {
        $(this).toggleClass("sidenavToggler-right-border");
        $("div .dc-chart").toggleClass("dc-hide");
        $(".dc").toggleClass("dc-hide");
    });

    $(".navbar-toggler-icon").click(function() {
        $(".leaflet-control-layers").toggleClass("dc-hide");
        $(".explain").toggleClass("dc-hide");
    });

    $('.dc-chart svg').ready(function() {
        setTimeout(function() {
            $('.dc').css("display", "block");
        }, 50);
    });

}


